import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

export type VisMode = 'sphere' | 'waveform' | 'bars' | 'tunnel' | 'galaxy';

type Uniforms = {
  uTime: { value: number };
  uLevel: { value: number };
};

export class BloomScene {
  private renderer: THREE.WebGLRenderer;
  private scene = new THREE.Scene();
  private camera: THREE.PerspectiveCamera;
  private controls: OrbitControls;
  private composer: EffectComposer;
  private visualObject!: THREE.Object3D;
  private uniforms: Uniforms = {
    uTime: { value: 0 },
    uLevel: { value: 0 },
  };
  private clock = new THREE.Clock();
  private mode: VisMode = 'sphere';
  private peakLevel = 0;
  private frameCount = 0;
  private lastTime = performance.now();
  public fps = 0;

  constructor(canvas: HTMLCanvasElement) {
    this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    this.renderer.setSize(innerWidth, innerHeight);
    this.renderer.setClearColor(0x000000, 1);

    this.camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 100);
    this.camera.position.set(0, 0, 2.5);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.autoRotate = true;
    this.controls.autoRotateSpeed = 0.5;

    this.scene.fog = new THREE.FogExp2(0x000000, 0.15);

    this.setMode('sphere');

    const size = new THREE.Vector2();
    this.renderer.getSize(size);
    this.composer = new EffectComposer(this.renderer);
    this.composer.addPass(new RenderPass(this.scene, this.camera));
    this.composer.addPass(new UnrealBloomPass(size, 1.5, 0.4, 0.1));

    window.addEventListener('resize', () => this.onResize());
  }

  reset() {
    this.camera.position.set(0, 0, 2.5);
    this.controls.reset();
    this.uniforms.uTime.value = 0;
    this.uniforms.uLevel.value = 0;
    this.peakLevel = 0;
  }

  setMode(mode: VisMode) {
    this.mode = mode;
    if (this.visualObject) {
      this.scene.remove(this.visualObject);
    }

    switch (this.mode) {
      case 'sphere':
        this.visualObject = this.makeSphere(60000);
        break;
      case 'waveform':
        this.visualObject = this.makeWaveform();
        break;
      case 'bars':
        this.visualObject = this.makeBars();
        break;
      case 'tunnel':
        this.visualObject = this.makeTunnel();
        break;
      case 'galaxy':
        this.visualObject = this.makeGalaxy();
        break;
    }

    this.scene.add(this.visualObject);
  }

  private makeSphere(count: number) {
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const seed = new Float32Array(count);
    
    for (let i = 0; i < count; i++) {
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const r = 0.8 + Math.random() * 0.3;
      pos[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
      pos[i * 3 + 1] = r * Math.cos(phi);
      pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
      seed[i] = Math.random() * 100.0;
    }
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    g.setAttribute('aSeed', new THREE.BufferAttribute(seed, 1));

    const material = new THREE.ShaderMaterial({
      uniforms: this.uniforms as any,
      vertexShader: `
        uniform float uTime;
        uniform float uLevel;
        attribute float aSeed;
        varying float vAlpha;
        varying float vDist;
        varying float vLevel;
        
        float hash(float n) { return fract(sin(n) * 43758.5453); }
        
        void main() {
          vec3 p = position;
          float t = uTime * 0.8 + aSeed;
          
          // More expressive wobble based on audio
          float wob = (hash(t) * 2.0 - 1.0) * 0.02 * (1.0 + uLevel * 2.0);
          
          // Dramatic expansion
          float inflate = 1.0 + uLevel * 1.2;
          p *= inflate;
          
          // Pulse outward
          p += normalize(p) * wob * (1.0 + uLevel);
          
          vDist = length(position);
          vAlpha = 0.3 + uLevel * 0.7;
          vLevel = uLevel;
          
          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;
          gl_PointSize = (1.0 + uLevel * 10.0) * (1.0 / -mv.z);
        }
      `,
      fragmentShader: `
        precision mediump float;
        varying float vAlpha;
        varying float vDist;
        varying float vLevel;
        
        void main() {
          vec2 uv = gl_PointCoord * 2.0 - 1.0;
          float d = dot(uv, uv);
          float m = smoothstep(1.0, 0.0, d);
          
          // Dynamic color based on distance and level
          vec3 color1 = vec3(0.0, 1.0, 0.53);  // Accent green
          vec3 color2 = vec3(0.0, 0.8, 1.0);   // Cyan
          vec3 color3 = vec3(1.0, 0.3, 0.8);   // Pink
          
          vec3 col = mix(color1, color2, vDist);
          col = mix(col, color3, vLevel * 0.5);
          
          gl_FragColor = vec4(col, m * vAlpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });
    return new THREE.Points(g, material);
  }

  private makeWaveform() {
    const g = new THREE.BufferGeometry();
    const count = 512;
    const pos = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      pos[i * 3 + 0] = (i / count - 0.5) * 8;
      pos[i * 3 + 1] = 0;
      pos[i * 3 + 2] = 0;
    }
    
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));

    const material = new THREE.LineBasicMaterial({
      color: 0x00ff88,
      linewidth: 3,
      transparent: true,
      opacity: 0.9
    });

    const line = new THREE.Line(g, material);
    (line as any).isWaveform = true;
    return line;
  }

  private makeBars() {
    const group = new THREE.Group();
    const barCount = 128;
    
    for (let i = 0; i < barCount; i++) {
      const geometry = new THREE.BoxGeometry(0.04, 0.05, 0.04);
      const hue = i / barCount;
      const material = new THREE.MeshBasicMaterial({
        color: new THREE.Color().setHSL(hue, 0.9, 0.5),
        transparent: true,
        opacity: 0.9
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      const angle = (i / barCount) * Math.PI * 2;
      const radius = 1.2;
      mesh.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
      mesh.rotation.y = -angle;
      group.add(mesh);
    }
    
    (group as any).isBars = true;
    return group;
  }

  private makeTunnel() {
    const g = new THREE.BufferGeometry();
    const count = 30000;
    const pos = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const radius = 0.8 + Math.random() * 0.6;
      const z = (Math.random() - 0.5) * 15;
      pos[i * 3 + 0] = Math.cos(angle) * radius;
      pos[i * 3 + 1] = Math.sin(angle) * radius;
      pos[i * 3 + 2] = z;
      
      const dist = Math.abs(z) / 15;
      colors[i * 3 + 0] = 0.0;
      colors[i * 3 + 1] = 1.0 - dist * 0.5;
      colors[i * 3 + 2] = 0.5 + dist * 0.5;
    }
    
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    g.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.04,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });

    const points = new THREE.Points(g, material);
    (points as any).isTunnel = true;
    return points;
  }

  private makeGalaxy() {
    const g = new THREE.BufferGeometry();
    const count = 80000;
    const pos = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      const radius = Math.random() * 4;
      const spinAngle = radius * 3;
      const branchAngle = ((i % 5) / 5) * Math.PI * 2;
      const angle = branchAngle + spinAngle;
      
      const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 0.3;
      const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 0.3;
      const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 0.3;
      
      pos[i * 3 + 0] = Math.cos(angle) * radius + randomX;
      pos[i * 3 + 1] = randomY;
      pos[i * 3 + 2] = Math.sin(angle) * radius + randomZ;
      
      const mixedColor = new THREE.Color();
      const innerColor = new THREE.Color(0x00ff88);
      const outerColor = new THREE.Color(0xff00ff);
      mixedColor.lerpColors(innerColor, outerColor, radius / 4);
      
      colors[i * 3 + 0] = mixedColor.r;
      colors[i * 3 + 1] = mixedColor.g;
      colors[i * 3 + 2] = mixedColor.b;
    }
    
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    g.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.015,
      vertexColors: true,
      transparent: true,
      opacity: 0.9,
      blending: THREE.AdditiveBlending,
      sizeAttenuation: true
    });

    const points = new THREE.Points(g, material);
    (points as any).isGalaxy = true;
    return points;
  }

  update(level: number, frequencyData?: Uint8Array<ArrayBuffer>) {
    const delta = this.clock.getDelta();
    this.uniforms.uTime.value += delta;
    
    // More responsive level changes
    this.peakLevel = Math.max(this.peakLevel * 0.95, level);
    this.uniforms.uLevel.value = THREE.MathUtils.damp(
      this.uniforms.uLevel.value, 
      this.peakLevel, 
      4, 
      delta
    );

    // FPS counter
    this.frameCount++;
    const now = performance.now();
    if (now - this.lastTime >= 1000) {
      this.fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
      this.frameCount = 0;
      this.lastTime = now;
    }

    // Mode-specific updates with more expression
    if ((this.visualObject as any).isWaveform && frequencyData) {
      this.updateWaveform(frequencyData);
    } else if ((this.visualObject as any).isBars && frequencyData) {
      this.updateBars(frequencyData);
    } else if ((this.visualObject as any).isTunnel) {
      const speed = 0.5 + level * 3;
      this.visualObject.rotation.z += delta * 0.4 * (1 + level);
      this.visualObject.position.z = (this.visualObject.position.z + delta * speed) % 15 - 7.5;
    } else if ((this.visualObject as any).isGalaxy) {
      this.visualObject.rotation.y += delta * 0.15 * (1 + level * 2);
      this.visualObject.rotation.x = Math.sin(this.uniforms.uTime.value * 0.2) * 0.2 * level;
    }

    this.controls.update();
    this.composer.render();
  }

  private updateWaveform(frequencyData: Uint8Array<ArrayBuffer>) {
    const line = this.visualObject as THREE.Line;
    const positions = line.geometry.attributes.position.array as Float32Array;
    
    for (let i = 0; i < positions.length / 3; i++) {
      const freq = frequencyData[i * 2] || 0;
      positions[i * 3 + 1] = (freq / 255) * 3 - 1.5;
    }
    
    line.geometry.attributes.position.needsUpdate = true;
    line.rotation.z += 0.001;
  }

  private updateBars(frequencyData: Uint8Array<ArrayBuffer>) {
    const group = this.visualObject as THREE.Group;
    const barCount = group.children.length;
    
    for (let i = 0; i < barCount; i++) {
      const mesh = group.children[i] as THREE.Mesh;
      const freq = frequencyData[Math.floor(i * frequencyData.length / barCount)] || 0;
      const height = (freq / 255) * 4 + 0.05;
      mesh.scale.y = height;
      mesh.position.y = height / 2;
    }
    
    group.rotation.y += 0.005;
  }

  private onResize() {
    const w = innerWidth, h = innerHeight;
    this.camera.aspect = w / h;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(w, h);
    this.composer.setSize(w, h);
  }
}
