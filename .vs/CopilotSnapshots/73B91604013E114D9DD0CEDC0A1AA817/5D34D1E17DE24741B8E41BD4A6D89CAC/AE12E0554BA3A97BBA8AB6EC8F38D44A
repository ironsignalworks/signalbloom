import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

export type VisMode = 'sphere' | 'waveform' | 'bars' | 'tunnel' | 'galaxy' | 'fractals';

type Uniforms = {
  uTime: { value: number };
  uLevel: { value: number };
};

export class BloomScene {
  private renderer: THREE.WebGLRenderer;
  private scene = new THREE.Scene();
  private camera: THREE.PerspectiveCamera;
  private controls: OrbitControls;
  private composer: EffectComposer;
  private visualObject!: THREE.Object3D;
  private uniforms: Uniforms = {
    uTime: { value: 0 },
    uLevel: { value: 0 },
  };
  private clock = new THREE.Clock();
  private mode: VisMode = 'sphere';
  private peakLevel = 0;
  private frameCount = 0;
  private lastTime = performance.now();
  public fps = 0;

  constructor(canvas: HTMLCanvasElement) {
    this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    this.renderer.setSize(innerWidth, innerHeight);
    this.renderer.setClearColor(0x000000, 1);

    this.camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 100);
    this.camera.position.set(0, 0, 2.5);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.autoRotate = true;
    this.controls.autoRotateSpeed = 0.5;

    this.scene.fog = new THREE.FogExp2(0x000000, 0.15);

    this.setMode('sphere');

    const size = new THREE.Vector2();
    this.renderer.getSize(size);
    this.composer = new EffectComposer(this.renderer);
    this.composer.addPass(new RenderPass(this.scene, this.camera));
    this.composer.addPass(new UnrealBloomPass(size, 1.5, 0.4, 0.1));

    window.addEventListener('resize', () => this.onResize());
  }

  reset() {
    this.camera.position.set(0, 0, 2.5);
    this.controls.reset();
    this.uniforms.uTime.value = 0;
    this.uniforms.uLevel.value = 0;
    this.peakLevel = 0;
  }

  setMode(mode: VisMode) {
    this.mode = mode;
    if (this.visualObject) {
      this.scene.remove(this.visualObject);
    }

    // Disable fog for texture and water modes (they need clear visibility)
    if (mode === 'texture' || mode === 'water') {
      this.scene.fog = null;
    } else {
      this.scene.fog = new THREE.FogExp2(0x000000, 0.15);
    }

    switch (this.mode) {
      case 'sphere':
        this.visualObject = this.makeSphere(60000);
        break;
      case 'waveform':
        this.visualObject = this.makeWaveform();
        break;
      case 'bars':
        this.visualObject = this.makeBars();
        break;
      case 'tunnel':
        this.visualObject = this.makeTunnel();
        break;
      case 'galaxy':
        this.visualObject = this.makeGalaxy();
        break;
      case 'fractals':
        this.visualObject = this.makeFractals();
        break;
      case 'texture':
        this.visualObject = this.makeTexture();
        break;
      case 'water':
        this.visualObject = this.makeWater();
        break;
    }

    this.scene.add(this.visualObject);
  }

  private makeSphere(count: number) {
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const seed = new Float32Array(count);
    
    for (let i = 0; i < count; i++) {
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const r = 0.8 + Math.random() * 0.3;
      pos[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
      pos[i * 3 + 1] = r * Math.cos(phi);
      pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
      seed[i] = Math.random() * 100.0;
    }
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    g.setAttribute('aSeed', new THREE.BufferAttribute(seed, 1));

    const material = new THREE.ShaderMaterial({
      uniforms: this.uniforms as any,
      vertexShader: `
        uniform float uTime;
        uniform float uLevel;
        attribute float aSeed;
        varying float vAlpha;
        varying float vDist;
        varying float vLevel;
        
        float hash(float n) { return fract(sin(n) * 43758.5453); }
        
        void main() {
          vec3 p = position;
          float t = uTime * 0.8 + aSeed;
          
          // More expressive wobble based on audio
          float wob = (hash(t) * 2.0 - 1.0) * 0.02 * (1.0 + uLevel * 2.0);
          
          // Dramatic expansion
          float inflate = 1.0 + uLevel * 1.2;
          p *= inflate;
          
          // Pulse outward
          p += normalize(p) * wob * (1.0 + uLevel);
          
          vDist = length(position);
          vAlpha = 0.3 + uLevel * 0.7;
          vLevel = uLevel;
          
          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;
          gl_PointSize = (1.0 + uLevel * 10.0) * (1.0 / -mv.z);
        }
      `,
      fragmentShader: `
        precision mediump float;
        varying float vAlpha;
        varying float vDist;
        varying float vLevel;
        
        void main() {
          vec2 uv = gl_PointCoord * 2.0 - 1.0;
          float d = dot(uv, uv);
          float m = smoothstep(1.0, 0.0, d);
          
          // Dynamic color based on distance and level
          vec3 color1 = vec3(0.0, 1.0, 0.53);  // Accent green
          vec3 color2 = vec3(0.0, 0.8, 1.0);   // Cyan
          vec3 color3 = vec3(1.0, 0.3, 0.8);   // Pink
          
          vec3 col = mix(color1, color2, vDist);
          col = mix(col, color3, vLevel * 0.5);
          
          gl_FragColor = vec4(col, m * vAlpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });
    return new THREE.Points(g, material);
  }

  private makeWaveform() {
    const g = new THREE.BufferGeometry();
    const count = 512;
    const pos = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      pos[i * 3 + 0] = (i / count - 0.5) * 8;
      pos[i * 3 + 1] = 0;
      pos[i * 3 + 2] = 0;
    }
    
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));

    const material = new THREE.LineBasicMaterial({
      color: 0x00ff88,
      linewidth: 3,
      transparent: true,
      opacity: 0.9
    });

    const line = new THREE.Line(g, material);
    (line as any).isWaveform = true;
    return line;
  }

  private makeBars() {
    const group = new THREE.Group();
    const barCount = 128;
    
    for (let i = 0; i < barCount; i++) {
      const geometry = new THREE.BoxGeometry(0.04, 0.05, 0.04);
      const hue = i / barCount;
      const material = new THREE.MeshBasicMaterial({
        color: new THREE.Color().setHSL(hue, 0.9, 0.5),
        transparent: true,
        opacity: 0.9
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      const angle = (i / barCount) * Math.PI * 2;
      const radius = 1.2;
      mesh.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
      mesh.rotation.y = -angle;
      group.add(mesh);
    }
    
    (group as any).isBars = true;
    return group;
  }

  private makeTunnel() {
    const g = new THREE.BufferGeometry();
    const count = 30000;
    const pos = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const radius = 0.8 + Math.random() * 0.6;
      const z = (Math.random() - 0.5) * 15;
      pos[i * 3 + 0] = Math.cos(angle) * radius;
      pos[i * 3 + 1] = Math.sin(angle) * radius;
      pos[i * 3 + 2] = z;
      
      const dist = Math.abs(z) / 15;
      colors[i * 3 + 0] = 0.0;
      colors[i * 3 + 1] = 1.0 - dist * 0.5;
      colors[i * 3 + 2] = 0.5 + dist * 0.5;
    }
    
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    g.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.04,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });

    const points = new THREE.Points(g, material);
    (points as any).isTunnel = true;
    return points;
  }

  private makeGalaxy() {
    const g = new THREE.BufferGeometry();
    const count = 80000;
    const pos = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      const radius = Math.random() * 4;
      const spinAngle = radius * 3;
      const branchAngle = ((i % 5) / 5) * Math.PI * 2;
      const angle = branchAngle + spinAngle;
      
      const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 0.3;
      const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 0.3;
      const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 0.3;
      
      pos[i * 3 + 0] = Math.cos(angle) * radius + randomX;
      pos[i * 3 + 1] = randomY;
      pos[i * 3 + 2] = Math.sin(angle) * radius + randomZ;
      
      const mixedColor = new THREE.Color();
      const innerColor = new THREE.Color(0x00ff88);
      const outerColor = new THREE.Color(0xff00ff);
      mixedColor.lerpColors(innerColor, outerColor, radius / 4);
      
      colors[i * 3 + 0] = mixedColor.r;
      colors[i * 3 + 1] = mixedColor.g;
      colors[i * 3 + 2] = mixedColor.b;
    }
    
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    g.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.015,
      vertexColors: true,
      transparent: true,
      opacity: 0.9,
      blending: THREE.AdditiveBlending,
      sizeAttenuation: true
    });

    const points = new THREE.Points(g, material);
    (points as any).isGalaxy = true;
    return points;
  }

  private makeFractals() {
    const group = new THREE.Group();
    
    // Reduced iterations for better performance (3 instead of 5)
    const iterations = 3;
    const baseSize = 1.5;
    
    const createFractalLevel = (level: number, size: number, position: THREE.Vector3) => {
      const geometry = new THREE.OctahedronGeometry(size, 0);
      const material = new THREE.MeshBasicMaterial({
        color: new THREE.Color().setHSL(level / iterations, 0.8, 0.5),
        wireframe: true,
        transparent: true,
        opacity: 0.6
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      group.add(mesh);
      
      if (level === 0) return;
      
      const newSize = size * 0.5;
      const offset = size * 0.6;
      
      // Only create 4 children instead of 6 for performance
      const positions = [
        new THREE.Vector3(offset, 0, 0),
        new THREE.Vector3(-offset, 0, 0),
        new THREE.Vector3(0, offset, 0),
        new THREE.Vector3(0, -offset, 0),
      ];
      
      positions.forEach(pos => {
        createFractalLevel(level - 1, newSize, position.clone().add(pos));
      });
    };
    
    createFractalLevel(iterations, baseSize, new THREE.Vector3(0, 0, 0));
    
    (group as any).isFractals = true;
    return group;
  }

  private makeTexture() {
    // Create a plane with procedural texture
    const geometry = new THREE.PlaneGeometry(4, 4, 64, 64);
    
    // Create separate uniforms for this material
    const textureUniforms = {
      uTime: this.uniforms.uTime,
      uLevel: this.uniforms.uLevel,
    };
    
    const material = new THREE.ShaderMaterial({
      uniforms: textureUniforms,
      vertexShader: `
        uniform float uTime;
        uniform float uLevel;
        varying vec2 vUv;
        varying float vElevation;
        
        void main() {
          vUv = uv;
          vec3 pos = position;
          
          // Audio-reactive wave displacement
          float wave1 = sin(pos.x * 3.0 + uTime * 2.0) * 0.1;
          float wave2 = sin(pos.y * 4.0 - uTime * 1.5) * 0.1;
          float elevation = (wave1 + wave2) * (1.0 + uLevel * 2.0);
          
          pos.z += elevation;
          vElevation = elevation;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        precision mediump float;
        uniform float uTime;
        uniform float uLevel;
        varying vec2 vUv;
        varying float vElevation;
        
        void main() {
          // Procedural pattern
          vec2 uv = vUv * 10.0;
          float pattern = sin(uv.x + uTime) * sin(uv.y + uTime * 0.7);
          pattern = pattern * 0.5 + 0.5;
          
          // Brighter colors with higher base intensity
          vec3 color1 = vec3(0.0, 1.0, 0.53);
          vec3 color2 = vec3(0.0, 0.8, 1.0);
          vec3 color3 = vec3(1.0, 0.3, 0.8);
          
          vec3 col = mix(color1, color2, pattern);
          col = mix(col, color3, abs(vElevation) + uLevel * 0.5);
          
          // Increase brightness for visibility with bloom
          col *= 1.5;
          
          gl_FragColor = vec4(col, 1.0);
        }
      `,
      transparent: false,
      side: THREE.DoubleSide,
      depthWrite: true,
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    (mesh as any).isTexture = true;
    return mesh;
  }

  private makeWater() {
    const geometry = new THREE.PlaneGeometry(5, 5, 128, 128);
    
    // Create separate uniforms for this material
    const waterUniforms = {
      uTime: this.uniforms.uTime,
      uLevel: this.uniforms.uLevel,
    };
    
    const material = new THREE.ShaderMaterial({
      uniforms: waterUniforms,
      vertexShader: `
        uniform float uTime;
        uniform float uLevel;
        varying vec3 vPosition;
        varying float vWave;
        
        void main() {
          vec3 pos = position;
          
          // Multiple wave layers
          float wave1 = sin(pos.x * 2.0 + uTime * 1.5) * 0.15;
          float wave2 = sin(pos.y * 3.0 + uTime * 2.0) * 0.12;
          float wave3 = sin((pos.x + pos.y) * 1.5 + uTime * 1.0) * 0.1;
          
          float totalWave = (wave1 + wave2 + wave3) * (1.0 + uLevel * 3.0);
          pos.z = totalWave;
          
          vPosition = pos;
          vWave = totalWave;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        precision mediump float;
        uniform float uTime;
        uniform float uLevel;
        varying vec3 vPosition;
        varying float vWave;
        
        void main() {
          // Brighter water colors
          vec3 deepWater = vec3(0.0, 0.5, 0.8);
          vec3 shallowWater = vec3(0.2, 1.0, 1.0);
          vec3 foam = vec3(1.0, 1.0, 1.0);
          
          // Mix colors based on wave height
          vec3 col = mix(deepWater, shallowWater, vWave + 0.5);
          col = mix(col, foam, max(0.0, vWave * 2.0) * uLevel);
          
          // Add shimmer
          float shimmer = sin(vPosition.x * 20.0 + uTime * 3.0) * 
                         sin(vPosition.y * 20.0 + uTime * 2.5);
          col += vec3(shimmer * 0.2 * (1.0 + uLevel));
          
          // Increase overall brightness
          col *= 1.3;
          
          gl_FragColor = vec4(col, 1.0);
        }
      `,
      transparent: false,
      side: THREE.DoubleSide,
      depthWrite: true,
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.rotation.x = -Math.PI / 2;
    (mesh as any).isWater = true;
    
    return mesh;
  }

  update(level: number, frequencyData?: Uint8Array<ArrayBuffer>) {
    const delta = this.clock.getDelta();
    this.uniforms.uTime.value += delta;
    
    // More responsive level changes
    this.peakLevel = Math.max(this.peakLevel * 0.95, level);
    this.uniforms.uLevel.value = THREE.MathUtils.damp(
      this.uniforms.uLevel.value, 
      this.peakLevel, 
      4, 
      delta
    );

    // FPS counter
    this.frameCount++;
    const now = performance.now();
    if (now - this.lastTime >= 1000) {
      this.fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
      this.frameCount = 0;
      this.lastTime = now;
    }

    // Mode-specific updates with more expression
    if ((this.visualObject as any).isWaveform && frequencyData) {
      this.updateWaveform(frequencyData);
    } else if ((this.visualObject as any).isBars && frequencyData) {
      this.updateBars(frequencyData);
    } else if ((this.visualObject as any).isTunnel) {
      const speed = 0.5 + level * 3;
      this.visualObject.rotation.z += delta * 0.4 * (1 + level);
      this.visualObject.position.z = (this.visualObject.position.z + delta * speed) % 15 - 7.5;
    } else if ((this.visualObject as any).isGalaxy) {
      this.visualObject.rotation.y += delta * 0.15 * (1 + level * 2);
      this.visualObject.rotation.x = Math.sin(this.uniforms.uTime.value * 0.2) * 0.2 * level;
    } else if ((this.visualObject as any).isFractals) {
      this.visualObject.rotation.y += delta * 0.3 * (1 + level);
      this.visualObject.rotation.x += delta * 0.2 * (1 + level);
      this.visualObject.scale.setScalar(1 + level * 0.3);
    } else if ((this.visualObject as any).isTexture) {
      this.visualObject.rotation.z += delta * 0.1;
    } else if ((this.visualObject as any).isWater) {
      // Water animates via shader
    }

    this.controls.update();
    this.composer.render();
  }

  private updateWaveform(frequencyData: Uint8Array<ArrayBuffer>) {
    const line = this.visualObject as THREE.Line;
    const positions = line.geometry.attributes.position.array as Float32Array;
    
    for (let i = 0; i < positions.length / 3; i++) {
      const freq = frequencyData[i * 2] || 0;
      positions[i * 3 + 1] = (freq / 255) * 3 - 1.5;
    }
    
    line.geometry.attributes.position.needsUpdate = true;
    line.rotation.z += 0.001;
  }

  private updateBars(frequencyData: Uint8Array<ArrayBuffer>) {
    const group = this.visualObject as THREE.Group;
    const barCount = group.children.length;
    
    for (let i = 0; i < barCount; i++) {
      const mesh = group.children[i] as THREE.Mesh;
      const freq = frequencyData[Math.floor(i * frequencyData.length / barCount)] || 0;
      const height = (freq / 255) * 4 + 0.05;
      mesh.scale.y = height;
      mesh.position.y = height / 2;
    }
    
    group.rotation.y += 0.005;
  }

  private onResize() {
    const w = innerWidth, h = innerHeight;
    this.camera.aspect = w / h;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(w, h);
    this.composer.setSize(w, h);
  }
}
