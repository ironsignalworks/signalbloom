import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

type Uniforms = {
  uTime: { value: number };
  uLevel: { value: number };
};

export class BloomScene {
  private renderer: THREE.WebGLRenderer;
  private scene = new THREE.Scene();
  private camera: THREE.PerspectiveCamera;
  private controls: OrbitControls;
  private composer: EffectComposer;
  private points!: THREE.Points;
  private uniforms: Uniforms = {
    uTime: { value: 0 },
    uLevel: { value: 0 },
  };
  private clock = new THREE.Clock();

  constructor(private canvas: HTMLCanvasElement) {
    this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    this.renderer.setSize(innerWidth, innerHeight);
    this.renderer.setClearColor(0x0b0f12, 1);

    this.camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
    this.camera.position.set(0, 0.5, 3);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;

    // subtle fog glow
    this.scene.fog = new THREE.FogExp2(0x0b0f12, 0.25);

    this.points = this.makeParticles(45000);
    this.scene.add(this.points);

    // post
    const size = new THREE.Vector2();
    this.renderer.getSize(size);
    this.composer = new EffectComposer(this.renderer);
    this.composer.addPass(new RenderPass(this.scene, this.camera));
    this.composer.addPass(new UnrealBloomPass(size, 0.8, 0.9, 0.1));

    window.addEventListener('resize', () => this.onResize());
  }

  private makeParticles(count: number) {
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const seed = new Float32Array(count);
    // distribute on a sphere
    for (let i = 0; i < count; i++) {
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const r = 1.0 + (Math.random() * 0.15 - 0.075);
      pos[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
      pos[i * 3 + 1] = r * Math.cos(phi);
      pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
      seed[i] = Math.random() * 1000.0;
    }
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    g.setAttribute('aSeed', new THREE.BufferAttribute(seed, 1));

    const material = new THREE.ShaderMaterial({
      uniforms: this.uniforms as any,
      vertexShader: `
        uniform float uTime;
        uniform float uLevel;
        attribute float aSeed;
        varying float vAlpha;
        // cheap noise-ish wobble
        float hash(float n){ return fract(sin(n)*43758.5453); }
        void main(){
          vec3 p = position;
          float t = uTime*0.6 + aSeed;
          float wob = (hash(t)*2.0-1.0) * 0.01;
          // breathe radius with level
          float inflate = 1.0 + uLevel * 0.6;
          p *= inflate;
          p += normalize(p) * wob;
          vAlpha = 0.4 + uLevel * 0.6;
          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;
          gl_PointSize = 1.5 + uLevel * 6.0;
        }
      `,
      fragmentShader: `
        precision mediump float;
        varying float vAlpha;
        void main(){
          // soft round sprite
          vec2 uv = gl_PointCoord * 2.0 - 1.0;
          float d = dot(uv, uv);
          float m = smoothstep(1.0, 0.0, d);
          vec3 col = mix(vec3(0.30,0.65,1.0), vec3(1.0,0.85,0.6), m);
          gl_FragColor = vec4(col, m * vAlpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });
    return new THREE.Points(g, material);
  }

  update(level: number) {
    this.uniforms.uTime.value += this.clock.getDelta();
    // gentle easing
    this.uniforms.uLevel.value = THREE.MathUtils.damp(this.uniforms.uLevel.value, level, 3, this.clock.getDelta());
    this.controls.update();
    this.composer.render();
  }

  private onResize() {
    const w = innerWidth, h = innerHeight;
    this.camera.aspect = w / h;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(w, h);
    this.composer.setSize(w, h);
  }
}
