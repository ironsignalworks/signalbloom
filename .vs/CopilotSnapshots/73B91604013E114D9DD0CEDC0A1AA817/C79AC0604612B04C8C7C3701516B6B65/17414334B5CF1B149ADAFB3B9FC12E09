import { MicAnalyser } from './audio';
import { BloomScene } from './scene';
import type { VisMode } from './scene';

const canvas = document.getElementById('stage') as HTMLCanvasElement;
const startBtn = document.getElementById('start') as HTMLButtonElement;
const fileBtn = document.getElementById('fileBtn') as HTMLButtonElement;
const playBtn = document.getElementById('playBtn') as HTMLButtonElement;
const modeBtn = document.getElementById('modeBtn') as HTMLButtonElement;
const resetBtn = document.getElementById('resetBtn') as HTMLButtonElement;
const fileInput = document.getElementById('fileInput') as HTMLInputElement;
const gainEl = document.getElementById('gain') as HTMLInputElement;
const volumeEl = document.getElementById('volume') as HTMLInputElement;
const levelValue = document.getElementById('levelValue') as HTMLSpanElement;
const fpsValue = document.getElementById('fpsValue') as HTMLSpanElement;
const modeValue = document.getElementById('modeValue') as HTMLSpanElement;

const audio = new MicAnalyser();
const app = new BloomScene(canvas);

let running = false;
let isPaused = false;

const modes: VisMode[] = ['sphere', 'waveform', 'bars', 'tunnel', 'galaxy'];
let currentModeIndex = 0;

startBtn.addEventListener('click', async () => {
  try {
    await audio.init();
    running = true;
    startBtn.disabled = true;
    startBtn.classList.add('active');
    fileBtn.disabled = true;
    startBtn.textContent = '● Mic';
    playBtn.style.display = 'none';
    volumeEl.disabled = true;
  } catch (e) {
    console.error('Microphone error:', e);
    alert('Mic access denied. Upload audio file instead.');
  }
});

fileBtn.addEventListener('click', () => {
  fileInput.click();
});

fileInput.addEventListener('change', async (e) => {
  const file = (e.target as HTMLInputElement).files?.[0];
  if (!file) return;
  
  try {
    await audio.initFromFile(file);
    running = true;
    isPaused = false;
    startBtn.disabled = true;
    fileBtn.disabled = true;
    fileBtn.classList.add('active');
    fileBtn.textContent = `♪ ${file.name.slice(0, 12)}`;
    playBtn.textContent = '⏸';
    playBtn.style.display = 'inline-block';
    volumeEl.disabled = false;
    audio.setVolume(parseFloat(volumeEl.value));
  } catch (e) {
    console.error('File load error:', e);
    alert('Failed to load audio file.');
  }
});

playBtn.addEventListener('click', () => {
  if (!running) return;
  
  isPaused = audio.togglePlayPause();
  playBtn.textContent = isPaused ? '▶' : '⏸';
});

modeBtn.addEventListener('click', () => {
  currentModeIndex = (currentModeIndex + 1) % modes.length;
  const mode = modes[currentModeIndex];
  app.setMode(mode);
  modeValue.textContent = mode.toUpperCase();
});

resetBtn.addEventListener('click', () => {
  app.reset();
  
  // Reset audio if playing from file
  if (audio.bufferSource && !audio.isPaused) {
    audio.pause();
    setTimeout(() => audio.resume(), 100);
  }
});

gainEl.addEventListener('input', () => {
  audio.gain = parseFloat(gainEl.value);
});

volumeEl.addEventListener('input', () => {
  audio.setVolume(parseFloat(volumeEl.value));
});

// Initialize
audio.gain = parseFloat(gainEl.value);
audio.setVolume(parseFloat(volumeEl.value));

function loop() {
  const lvl = running ? audio.level() : 0.0;
  const freqData = running ? audio.getFrequencyData() : undefined;
  
  levelValue.textContent = `${Math.round(lvl * 100)}%`;
  fpsValue.textContent = `${app.fps}`;
  
  app.update(lvl, freqData);
  requestAnimationFrame(loop);
}
loop();
