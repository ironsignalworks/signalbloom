import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

export type VisMode = 'sphere' | 'waveform' | 'bars' | 'tunnel' | 'galaxy';

type Uniforms = {
  uTime: { value: number };
  uLevel: { value: number };
};

export class BloomScene {
  private renderer: THREE.WebGLRenderer;
  private scene = new THREE.Scene();
  private camera: THREE.PerspectiveCamera;
  private controls: OrbitControls;
  private composer: EffectComposer;
  private visualObject!: THREE.Object3D;
  private uniforms: Uniforms = {
    uTime: { value: 0 },
    uLevel: { value: 0 },
  };
  private clock = new THREE.Clock();
  private mode: VisMode = 'sphere';

  constructor(canvas: HTMLCanvasElement) {
    this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    this.renderer.setSize(innerWidth, innerHeight);
    this.renderer.setClearColor(0x0a0a0a, 1);

    this.camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
    this.camera.position.set(0, 0.5, 3);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;

    this.scene.fog = new THREE.FogExp2(0x0a0a0a, 0.25);

    this.setMode('sphere');

    // post
    const size = new THREE.Vector2();
    this.renderer.getSize(size);
    this.composer = new EffectComposer(this.renderer);
    this.composer.addPass(new RenderPass(this.scene, this.camera));
    this.composer.addPass(new UnrealBloomPass(size, 1.2, 0.9, 0.1));

    window.addEventListener('resize', () => this.onResize());
  }

  setMode(mode: VisMode) {
    this.mode = mode;
    if (this.visualObject) {
      this.scene.remove(this.visualObject);
    }

    switch (mode) {
      case 'sphere':
        this.visualObject = this.makeSphere(45000);
        break;
      case 'waveform':
        this.visualObject = this.makeWaveform();
        break;
      case 'bars':
        this.visualObject = this.makeBars();
        break;
      case 'tunnel':
        this.visualObject = this.makeTunnel();
        break;
      case 'galaxy':
        this.visualObject = this.makeGalaxy();
        break;
    }

    this.scene.add(this.visualObject);
  }

  private makeSphere(count: number) {
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const seed = new Float32Array(count);
    
    for (let i = 0; i < count; i++) {
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const r = 1.0 + (Math.random() * 0.15 - 0.075);
      pos[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
      pos[i * 3 + 1] = r * Math.cos(phi);
      pos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
      seed[i] = Math.random() * 1000.0;
    }
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    g.setAttribute('aSeed', new THREE.BufferAttribute(seed, 1));

    const material = new THREE.ShaderMaterial({
      uniforms: this.uniforms as any,
      vertexShader: `
        uniform float uTime;
        uniform float uLevel;
        attribute float aSeed;
        varying float vAlpha;
        // cheap noise-ish wobble
        float hash(float n){ return fract(sin(n)*43758.5453); }
        void main(){
          vec3 p = position;
          float t = uTime*0.6 + aSeed;
          float wob = (hash(t)*2.0-1.0) * 0.01;
          // breathe radius with level
          float inflate = 1.0 + uLevel * 0.6;
          p *= inflate;
          p += normalize(p) * wob;
          vAlpha = 0.4 + uLevel * 0.6;
          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;
          gl_PointSize = 1.5 + uLevel * 6.0;
        }
      `,
      fragmentShader: `
        precision mediump float;
        varying float vAlpha;
        void main(){
          // soft round sprite
          vec2 uv = gl_PointCoord * 2.0 - 1.0;
          float d = dot(uv, uv);
          float m = smoothstep(1.0, 0.0, d);
          vec3 col = mix(vec3(0.30,0.65,1.0), vec3(1.0,0.85,0.6), m);
          gl_FragColor = vec4(col, m * vAlpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });
    return new THREE.Points(g, material);
  }

  private makeWaveform() {
    const g = new THREE.BufferGeometry();
    const count = 512;
    const pos = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      pos[i * 3 + 0] = (i / count - 0.5) * 6;
      pos[i * 3 + 1] = 0;
      pos[i * 3 + 2] = 0;
    }
    
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));

    const material = new THREE.LineBasicMaterial({
      color: 0x00ff88,
      linewidth: 2,
      transparent: true,
      opacity: 0.8
    });

    const line = new THREE.Line(g, material);
    (line as any).isWaveform = true;
    return line;
  }

  private makeBars() {
    const group = new THREE.Group();
    const barCount = 64;
    
    for (let i = 0; i < barCount; i++) {
      const geometry = new THREE.BoxGeometry(0.08, 0.1, 0.08);
      const material = new THREE.MeshBasicMaterial({
        color: new THREE.Color().setHSL(i / barCount, 0.8, 0.5),
        transparent: true,
        opacity: 0.8
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      const angle = (i / barCount) * Math.PI * 2;
      const radius = 1.5;
      mesh.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
      group.add(mesh);
    }
    
    (group as any).isBars = true;
    return group;
  }

  private makeTunnel() {
    const g = new THREE.BufferGeometry();
    const count = 20000;
    const pos = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const radius = 1 + Math.random() * 0.5;
      const z = (Math.random() - 0.5) * 10;
      pos[i * 3 + 0] = Math.cos(angle) * radius;
      pos[i * 3 + 1] = Math.sin(angle) * radius;
      pos[i * 3 + 2] = z;
    }
    
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));

    const material = new THREE.PointsMaterial({
      color: 0x4488ff,
      size: 0.05,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending
    });

    const points = new THREE.Points(g, material);
    (points as any).isTunnel = true;
    return points;
  }

  private makeGalaxy() {
    const g = new THREE.BufferGeometry();
    const count = 50000;
    const pos = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      const radius = Math.random() * 3;
      const spinAngle = radius * 2;
      const angle = Math.random() * Math.PI * 2 + spinAngle;
      
      pos[i * 3 + 0] = Math.cos(angle) * radius;
      pos[i * 3 + 1] = (Math.random() - 0.5) * 0.3;
      pos[i * 3 + 2] = Math.sin(angle) * radius;
      
      const colorVal = Math.random();
      colors[i * 3 + 0] = colorVal * 0.5 + 0.5;
      colors[i * 3 + 1] = colorVal * 0.3 + 0.7;
      colors[i * 3 + 2] = 1.0;
    }
    
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    g.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.02,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });

    const points = new THREE.Points(g, material);
    (points as any).isGalaxy = true;
    return points;
  }

  update(level: number, frequencyData?: Uint8Array<ArrayBuffer>) {
    const delta = this.clock.getDelta();
    this.uniforms.uTime.value += delta;
    this.uniforms.uLevel.value = THREE.MathUtils.damp(this.uniforms.uLevel.value, level, 3, delta);

    // Mode-specific updates
    if ((this.visualObject as any).isWaveform && frequencyData) {
      this.updateWaveform(frequencyData);
    } else if ((this.visualObject as any).isBars && frequencyData) {
      this.updateBars(level, frequencyData);
    } else if ((this.visualObject as any).isTunnel) {
      this.visualObject.rotation.z += delta * 0.3 * (1 + level);
      this.visualObject.position.z = (this.visualObject.position.z + delta * 2) % 10 - 5;
    } else if ((this.visualObject as any).isGalaxy) {
      this.visualObject.rotation.y += delta * 0.2 * (1 + level);
    }

    this.controls.update();
    this.composer.render();
  }

  private updateWaveform(frequencyData: Uint8Array<ArrayBuffer>) {
    const line = this.visualObject as THREE.Line;
    const positions = line.geometry.attributes.position.array as Float32Array;
    
    for (let i = 0; i < positions.length / 3; i++) {
      const freq = frequencyData[i] || 0;
      positions[i * 3 + 1] = (freq / 255) * 2 - 1;
    }
    
    line.geometry.attributes.position.needsUpdate = true;
  }

  private updateBars(level: number, frequencyData: Uint8Array<ArrayBuffer>) {
    const group = this.visualObject as THREE.Group;
    const barCount = group.children.length;
    
    for (let i = 0; i < barCount; i++) {
      const mesh = group.children[i] as THREE.Mesh;
      const freq = frequencyData[Math.floor(i * frequencyData.length / barCount)] || 0;
      const height = (freq / 255) * 3 + 0.1;
      mesh.scale.y = height;
      mesh.position.y = height / 2;
    }
  }

  private onResize() {
    const w = innerWidth, h = innerHeight;
    this.camera.aspect = w / h;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(w, h);
    this.composer.setSize(w, h);
  }
}
